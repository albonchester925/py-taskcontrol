<h1>taskcontrol</h1>
<pre><code>Create named shared / isolated workflow task controls, and run them with respective before/after middlewares. taskcontrols also supports plugins, concurrency, and authentication
</code></pre>
<h1>Features Details</h1>
<ul>
<li>Create Named task controls (tasks) using a Workflow decorator with simple options to setup workflow</li>
<li>Allows middlewares before each task (data fetch, auth, etc)</li>
<li>Allows middlewares after each task (data save, logging, logout, cleanup, etc)</li>
<li>Allows context (currently read-only) for each set of tasks run accessible by any function</li>
<li>Allows accessing returns/results of runs by each task or their middlewares</li>
<li>Allows creating isolated instance tasks or common/shared tasks based on shared keyword argument</li>
<li>Allows creating and merging two instances of task controls with namespace clash handling</li>
<li>Allows running single or multiple isolated, shared, or mixed tasks for each set of tasks run
<!-- * In-Development: Allows creating, registering, and using a set of task controls as a plugin -->
<!-- * In-Development: Allows  --></li>
</ul>
<!-- # Feature Details -->

<h1>Demo Usage</h1>
<ul>
<li>Import workflow and Tasks object from workflow module in taskcontrol package</li>
<li>Create a Task instance</li>
<li>Create a workflow definition using <code>@workflow</code> decorator<ul>
<li>Usage: <ul>
<li><code>@workflow(name, task_order, task_instance, args, kwargs, before, after, shared, log)</code></li>
<li><code>def function(...){...}</code></li>
</ul>
</li>
<li><code>name</code>, <code>task_instance</code> keys definitions are compulsary</li>
<li><code>args</code>, <code>kwargs</code>, optional for function arguments - throws <code>TypeError</code> if wrong args provided</li>
<li><code>before</code> and <code>after</code> keys are optional and provides before and after middlewares for a specific task</li>
<li><code>shared</code> key is optional and defaults to <code>False</code></li>
<li><code>log</code> key is optional and default to <code>False</code></li>
</ul>
</li>
<li>Run the task when needed using <code>.run(tasks=['taskname'])</code> invocation</li>
</ul>
<h2>Demo Usage</h2>
<p>```python</p>
<h1>for package</h1>
<p>from taskcontrol.workflow import workflow, Tasks</p>
<h1>Create an instance of the task you are creating</h1>
<p>sparrow = Tasks()</p>
<h1>Middleware that we are running</h1>
<h1>Use any middleware that runs with or withour returning results</h1>
<h1>Demo uses common middleware for all. Please use you own middlewares</h1>
<p>def nesttree(ctx, result, k, c, d, **kwargs):
    print("Running my Middleware Function: nesttree - task items", k, c, d, kwargs)</p>
<h1>workflow decorator</h1>
<p>@workflow(</p>
<pre><code># Task name
name="taskname",

# Order of the task function when all tasks are run (Not functional yet)
task_order=1,

# Task instance whic is used for creating tasks
# Tasks are isolated to this task instance
task_instance=sparrow,

# Whether the Task is a shared task or instance isolated task
# Shared Task is sharable and accessable across the app
shared=False,

# Arguments that should be provided to the task function the decorator is applied on
args=[1, 2],

# Keyword arguments for the function the decorator is applied on
kwargs={},

# before middleware order followed will be of the list sequence
before=[
    {
        "function": nesttree,
        "args": [11, 12],
        "kwargs": {"d": "Before Testing message Middleware "},
        "options": {"error": "next", "error_next_value": ""}
    }
],

# after middleware order followed will be of the list sequence
after=[
    {
        "function": nesttree,
        "args": [13, 14],
        "kwargs": {"d": "After Middleware Testing message"},
        "options": {
            "error": "error_handler",
            "error_next_value": "value",
            "error_handler": lambda err, value: (err, None)
        }
    }
],

# Whether logging should be allowed or not (Not functional yet)
log=False
</code></pre>
<p>)</p>
<h1>Main function for the task</h1>
<p>def taskone(ctx, result, a, b):
    print("Running my task function: taskone", a, b)</p>
<p>sparrow.run(tasks="taskname")</p>
<p>```</p>